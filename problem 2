import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable

plt.style.use('ggplot') #to be used for pthe plot in task a

#Making transition matrix
P = np.array([[0.95, 0.05], [0, 1]])
#initialized vector
x = np.array([0.99, 0.01])

#a
def task_a(P, x):
	'''
	Doing 50 iterations and storing the probability for class 2
	'''
	#list to append probabilities and appending the first probability
	probabilities = []
	probabilities.append(x[0])
	probabilities.append(x[1])
	#doing 50 iterations
	for _ in range (49):
		x = np.dot(x, P) #
		probabilities.append(x[0])
		probabilities.append(x[1])
	
	return probabilities

def plot_a(P,x):
	'''
	plotting the probability as a funtion of n
	'''
	probabilities = task_a(P, x)
	#plotting marginal probabilities
	plt.figure()
	plt.plot(range(1,51), probabilities[::2])
	plt.title('Marginal probabilities for $P(X_n = 1)$ as function of $n$.', fontsize=14)
	plt.xlabel('$n$')
	plt.ylabel('$P(X_n = 1)$')
	plt.show()


#plot_a(P,x)


#b
def task_b_simulate_hill(n_sim, P, x):
	'''
	The problem is identical to a geometric distribution
	and is programmed in that way. A list of markov chains is returned
	'''
	#list to store each simulation
	realizations = []
	count = 0 # debugging
	#simulating
	for _ in range(n_sim):
		#setting all roads to risk 1
		x = np.ones((50,), dtype=np.int)
		
		#simulating each road
		for i in range(1,50):
			if i == 1:  #initial probability for i = 1
				prob = 0.99
			else:		#probability is 0.95 if i is not 1
				prob = 0.95
			#drawing from a uniform distribution
			random = np.random.uniform(0,1)
			if random > prob:
				#if there is a road of class 2 every road above is set to risk 2
				count+=i
				print('i = ', i, ' count = ', count) # debugging
				for n in range(50-i):
					x[i+n] = 2
				break

		realizations.append(x)
	
	#returning the list of the simulations
	print(count/50) # debugging
	return realizations

#task_b_simulate_hill(50, P, x)


def plot_b(P, x):
	'''
	plotting the realizations from task 2b with imshow
	'''
	image = task_b_simulate_hill(25, P, x)

	plt.figure()
	ax = plt.gca() #to size the colorbar
	im = ax.imshow(image)
	plt.title('$25$ realizations as a function of time')
	plt.xlabel('time')
	plt.ylabel('Realization number')
	#more stuff for the colorbar
	divider = make_axes_locatable(ax)
	cax = divider.append_axes("right", size="5%", pad=0.05)
	plt.colorbar(im, cax=cax)
	ax.set_ylim(ax.get_ylim()[::-1])
	#må få til å slutte aksene på siste verdi
	plt.show()

#plot_b(P, x)

#probabilities = task_a(P, x)
#print(probabilities[20])

def task_c(P, x, k):
	'''
	computing forward and backward probability
	'''
	#Forward probability:
	forward_probabilities_1 = [] # i = 1
	forward_probabilities_2 = [] # i = 2
	x1 = np.array([1,0])
	x2 = np.array([0,1])
	for _ in range(50-k):
		#x1 = np.dot(P, x1)#gjorde dette først
		#x2 = np.dot(P, x2)
		x1 = np.dot(x1, P)
		x2 = np.dot(x2, P)
		forward_probabilities_1.append(x1[0])
		forward_probabilities_2.append(x2[1])

	#Backward probability:
	#the probability for i=1 is 0 since we can't go from class 2 to class 1 
	probabilities = task_a(P, x)
	#finding backward transition matrix:
	A = np.array([[1, 0]])
	b = np.array([[1,0]])
	c =np.concatenate((A,b))
	print(c)
	
	



	backward_probabilities = []
	for l in range(k):
		#Bayes rule: P(A|B)= P(B|A)*P(A)/P(B)
		pba = 1
		#P(A)
		pa = 1-probabilities[l]
		#P(B) from a)
		pb = 1-probabilities[k-1]
		#P(A|B)
		pab = pba * pa / pb

		backward_probabilities.append(pab) #nå er det noe feil her

	#print(forward_probabilities_1, forward_probabilities_2, backward_probabilities) #debugging
	return forward_probabilities_1, forward_probabilities_2, backward_probabilities

def plot_c(P, x, k):
	forward_probabilities_1, forward_probabilities_2, backward_probabilities = task_c(P, x, k)

	plt.figure()
	plt.plot(range(50-k), forward_probabilities_1, label='class 1')
	plt.plot(range(50-k), forward_probabilities_2, label='class 2')
	plt.legend()
	plt.show()

	plt.figure()
	plt.plot(range(k), backward_probabilities, label='class 2')
	plt.plot(range(k), np.zeros(k), label='class 1')
	plt.legend()
	plt.show()

task_c(P, x, 20)
#plot_c(P, x, 20)

def task_d(P, x):
	'''
	This function gets the probabilities from task a 
	and sums over these with a cost of 5000 per road.
	'''
	probabilities = task_a(P, x)
	#print(probabilities)
	price = 0
	count = 0
	for prob in probabilities[1::2]:
		print(prob)
		price+=5000*prob
		count+=1
	print('\ntotal cost = ', price)
	print('optimal choice is: ')
	if price < 100000:
		print('5000 per road ')
	else:
		print('fixed price of 100000')
	print('count = ', count)

task_d(P, x)
'''
def inf_gain_at_k(P, x, k):
	forward_probabilities_1, backward_probabilities = task_c(P, x)
	total = 0
	for i in [1, 2]:
		price = 0
		for n in range(50):
			if n<k:
				price += 5000*backward_probabilities[k-1]#k-1 to get road k
			elif n>k:
				price += 5000*forward_probabilities_1[k-1]
			else:#n=k -> P(a|a)=1


		total += min(100000, price) * #P(X_k=i)




def task_e(P, x):
'''